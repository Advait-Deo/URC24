#include <Wire.h>
#include "Adafruit_TCS34725.h"


// Define pin numbers for the IR sensors
#define SENSOR_LEFT 35
#define SENSOR_CENTER 36
#define SENSOR_RIGHT 39

// --- Pin Definitions --- HCSR
#define TRIG_FRONT 6  // Front Ultrasonic Sensor Trigger Pin
#define ECHO_FRONT 7  // Front Ultrasonic Sensor Echo Pin
#define TRIG_RIGHT 8  // Right Ultrasonic Sensor Trigger Pin
#define ECHO_RIGHT 9  // Right Ultrasonic Sensor Echo Pin
#define TRIG_LEFT 10  // Left Ultrasonic Sensor Trigger Pin
#define ECHO_LEFT 11  // Left Ultrasonic Sensor Echo Pin

// --- Constants ---
const int safeDistance = 30; // Safe distance from walls in cm
const int setPoint = 15; // Desired distance from the right wall for PID

// Motor control pins for L298N motor driver
#define MOTOR_LEFT_FORWARD 32
#define MOTOR_LEFT_BACKWARD 33
#define MOTOR_RIGHT_FORWARD 25
#define MOTOR_RIGHT_BACKWARD 26

// Variables for PID control
float Kp = 1.5;  // Proportional gain (adjust to tune)
float Ki = 0.0;  // Integral gain (start with 0)
float Kd = 1.0;  // Derivative gain (adjust to tune)
float error = 0, previousError = 0;
float integral = 0;
float derivative = 0;
float correction = 0;
int baseSpeed = 150;  // Base motor speed (adjust depending on motor power)

// Motor speed limits (adjust depending on desired speed)
int maxSpeed = 255;
int minSpeed = 0;

// --- Dynamic Maze Grid ---
const int gridRows = 10;
const int gridCols = 10;
int mazeGrid[gridRows][gridCols]; // 2D array for mapping the maze
int currentX = 0, currentY = 0; // Current position in the grid

// --- Function Declarations ---
long readUltrasonicDistance(int trigPin, int echoPin);
void updateMazeWithSensors();
void followRightHandRule();
void maintainDistanceFromWall();
void moveForward();
void turnLeft();
void turnRight();
void turnAround();
void stopMotors();
void adjustMotors(float pidSpeed);

void setup() {
  // Set up sensor pins as input
  pinMode(SENSOR_LEFT, INPUT);
  pinMode(SENSOR_CENTER, INPUT);
  pinMode(SENSOR_RIGHT, INPUT);

  // Set up motor control pins as output
  pinMode(MOTOR_LEFT_FORWARD, OUTPUT);
  pinMode(MOTOR_LEFT_BACKWARD, OUTPUT);
  pinMode(MOTOR_RIGHT_FORWARD, OUTPUT);
  pinMode(MOTOR_RIGHT_BACKWARD, OUTPUT);

  Serial.begin(9600);  // Initialize serial communication for debugging

  // Setup Ultrasonic Pins
  pinMode(TRIG_FRONT, OUTPUT);
  pinMode(ECHO_FRONT, INPUT);
  pinMode(TRIG_RIGHT, OUTPUT);
  pinMode(ECHO_RIGHT, INPUT);
  pinMode(TRIG_LEFT, OUTPUT);
  pinMode(ECHO_LEFT, INPUT);
  
  // Initialize maze grid (0 = unexplored, 1 = wall, 2 = path)
  for (int i = 0; i < gridRows; i++) {
    for (int j = 0; j < gridCols; j++) {
      mazeGrid[i][j] = 0;
    }
  }
}

void loop() {
  // Read sensor values (LOW when detecting the black line)
  int leftValue = digitalRead(SENSOR_LEFT);
  int centerValue = digitalRead(SENSOR_CENTER);
  int rightValue = digitalRead(SENSOR_RIGHT);

  // Calculate the error based on sensor readings
  if (leftValue == LOW && rightValue == LOW && centerValue == HIGH) {
    error = 0;  // Robot is on track (center sensor detecting the line)
  } 
  else if (leftValue == HIGH && centerValue == LOW && rightValue == LOW) {
    error = -1;  // Robot is veering to the left (left sensor detecting the line)
  } 
  else if (leftValue == LOW && centerValue == LOW && rightValue == HIGH) {
    error = 1;  // Robot is veering to the right (right sensor detecting the line)
  }

  // Calculate PID terms
  integral += error;                           // Accumulate the integral term
  derivative = error - previousError;          // Calculate the derivative term
  correction = (Kp * error) + (Ki * integral) + (Kd * derivative);  // PID formula

  // Update motor speeds based on PID correction
  int leftMotorSpeed = baseSpeed + correction;   // Adjust left motor speed
  int rightMotorSpeed = baseSpeed - correction;  // Adjust right motor speed

  // Constrain motor speeds to within valid limits
  leftMotorSpeed = constrain(leftMotorSpeed, minSpeed, maxSpeed);
  rightMotorSpeed = constrain(rightMotorSpeed, minSpeed, maxSpeed);

  // Set motor speeds
  setMotorSpeed(MOTOR_LEFT_FORWARD, MOTOR_LEFT_BACKWARD, leftMotorSpeed);
  setMotorSpeed(MOTOR_RIGHT_FORWARD, MOTOR_RIGHT_BACKWARD, rightMotorSpeed);

  // Store the current error for the next loop iteration (used in derivative)
  previousError = error;

  // Small delay for stability (adjust as needed)
  delay(10);

  // Update the maze mapping based on sensor readings
  updateMazeWithSensors();

  // Use the Right-Hand Rule for basic maze exploration
  followRightHandRule();
}

// Function to control motor speed and direction using L298N motor driver
void setMotorSpeed(int forwardPin, int backwardPin, int speed) {
  if (speed >= 0) {
    analogWrite(forwardPin, speed);
    analogWrite(backwardPin, 0);
  } else {
    analogWrite(forwardPin, 0);
    analogWrite(backwardPin, -speed);
  }
}

// --- Function Definitions --- hcsr04

// Read distance from ultrasonic sensor
long readUltrasonicDistance(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  return pulseIn(echoPin, HIGH) / 58;  // Convert time to cm
}

// Update the maze grid with sensor readings
void updateMazeWithSensors() {
  long frontDist = readUltrasonicDistance(TRIG_FRONT, ECHO_FRONT);
  long rightDist = readUltrasonicDistance(TRIG_RIGHT, ECHO_RIGHT);
  long leftDist = readUltrasonicDistance(TRIG_LEFT, ECHO_LEFT);

  // Update grid based on sensor readings
  if (frontDist < safeDistance) {
    mazeGrid[currentX][currentY + 1] = 1; // Wall in front
  } else {
    mazeGrid[currentX][currentY + 1] = 0; // Path in front
  }

  if (rightDist < safeDistance) {
    mazeGrid[currentX + 1][currentY] = 1; // Wall to the right
  } else {
    mazeGrid[currentX + 1][currentY] = 0; // Path to the right
  }

  if (leftDist < safeDistance) {
    mazeGrid[currentX - 1][currentY] = 1; // Wall to the left
  } else {
    mazeGrid[currentX - 1][currentY] = 0; // Path to the left
  }
}

// Implement Right-Hand Rule navigation
void followRightHandRule() {
  long frontDist = readUltrasonicDistance(TRIG_FRONT, ECHO_FRONT);
  long rightDist = readUltrasonicDistance(TRIG_RIGHT, ECHO_RIGHT);
  long leftDist = readUltrasonicDistance(TRIG_LEFT, ECHO_LEFT);

  // Maintain PID-controlled distance from the right wall
  maintainDistanceFromWall();

  // Right-Hand Rule Logic
  if (rightDist > safeDistance) {
    turnRight();
    moveForward();
  } else if (frontDist > safeDistance) {
    moveForward();
  } else if (leftDist > safeDistance) {
    turnLeft();
    moveForward();
  } else {
    turnAround();
  }
}

// Use PID to maintain a consistent distance from the right wall
void maintainDistanceFromWall() {
  long rightDist = readUltrasonicDistance(TRIG_RIGHT, ECHO_RIGHT);

  // Calculate PID values
  error = setPoint - rightDist;
  integral += error;
  derivative = error - previousError;
  float motorSpeedAdjustment = (Kp * error) + (Ki * integral) + (Kd * derivative);

  // Adjust motor speeds based on PID output
  adjustMotors(motorSpeedAdjustment);

  previousError = error;
}

// Adjust motor speeds based on PID calculations
void adjustMotors(float pidSpeed) {
  float leftMotorSpeed = baseSpeed + pidSpeed;
  float rightMotorSpeed = baseSpeed - pidSpeed;

  leftMotorSpeed = constrain(leftMotorSpeed, 0, maxSpeed);
  rightMotorSpeed = constrain(rightMotorSpeed, 0, maxSpeed);

  analogWrite(MOTOR_LEFT_FORWARD, leftMotorSpeed);
  analogWrite(MOTOR_RIGHT_FORWARD, rightMotorSpeed);
}

// Move forward function
void moveForward() {
  analogWrite(MOTOR_LEFT_FORWARD, baseSpeed);
  analogWrite(MOTOR_RIGHT_FORWARD, baseSpeed);
}

// Turn left (90 degrees)
void turnLeft() {
  analogWrite(MOTOR_LEFT_BACKWARD, baseSpeed);
  analogWrite(MOTOR_RIGHT_FORWARD, baseSpeed);
  delay(500);  // Adjust this value for the 90-degree turn timing
  stopMotors();
}

// Turn right (90 degrees)
void turnRight() {
  analogWrite(MOTOR_LEFT_FORWARD, baseSpeed);
  analogWrite(MOTOR_RIGHT_BACKWARD, baseSpeed);
  delay(500);  // Adjust this value for the 90-degree turn timing
  stopMotors();
}

// Turn around (180 degrees)
void turnAround() {
  analogWrite(MOTOR_LEFT_FORWARD, baseSpeed);
  analogWrite(MOTOR_RIGHT_BACKWARD, baseSpeed);
  delay(1000);  // Adjust for 180-degree turn
  stopMotors();
}

// Stop both motors
void stopMotors() {
  analogWrite(MOTOR_LEFT_FORWARD, 0);
  analogWrite(MOTOR_RIGHT_FORWARD, 0);
  analogWrite(MOTOR_LEFT_BACKWARD, 0);
  analogWrite(MOTOR_RIGHT_BACKWARD, 0);
}
